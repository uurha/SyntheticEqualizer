using System;
using System.Threading.Tasks;
using Base.BaseTypes;
using Base.Deque;
using Extensions;
using Modules.Grid.Model;
using SubModules.Beom;
using SubModules.Cell.Interfaces;
using SubModules.Cell.Model;
using SubModules.Road.Generator;
using TaskExtensions = CorePlugin.Extensions.TaskExtensions;

namespace Modules.Grid.Systems.Generator
{
    public class GridGenerator
    {
        private readonly int _columnsCount;
        private readonly BeomCells _preset;
        private readonly int _rowCount;
        private readonly int _seed;
        private Deque<RoadDirection> _generatedPath;
        private int _lastColumn;
        private RoadDirection _lastEntity;
        private int _lastRow;
        private RoadGenerator _pathGenerator;

        public GridGenerator(int columnsCount, int rowCount, BeomCells preset, int seed)
        {
            _columnsCount = columnsCount;
            _rowCount = rowCount;
            _preset = preset;
            _seed = seed;
        }

        /// <summary>
        ///     Generates grid based on internal PathGenerator
        /// </summary>
        /// <param name="action"></param>
        public async void GenerateGrid(Action<GridGeneratorOutput> action)
        {
            _pathGenerator = new RoadGenerator(_columnsCount * _rowCount, _seed);
            _generatedPath = await _pathGenerator.GeneratePathAsync();
            _lastColumn = 0;
            _lastRow = 0;
            _lastEntity = RoadDirection.None;
            var generatedGrid = await GenerateGridAsync(_generatedPath);
            action?.Invoke(generatedGrid);
        }

        /// <summary>
        ///     Generates next grid part based on internal path generated by PathGenerator
        /// </summary>
        /// <param name="action"></param>
        /// <remarks>If path lenght less then stored row count or column count generates additional path part</remarks>
        public async void GenerateNextGrid(Action<GridGeneratorOutput> action)
        {
            for (var i = 0; i < 2; i++) _generatedPath.AddLast(_generatedPath.Last);

            if (_generatedPath.Count <= _rowCount ||
                _generatedPath.Count <= _columnsCount)
                _generatedPath.AddRangeFirst(await _pathGenerator.GeneratePathAsync());
            var generatedGrid = await GenerateGridAsync(_generatedPath);
            action?.Invoke(generatedGrid);
        }

        /// <summary>
        ///     Generates next grid part based on path generated by externally passed PathGenerator.
        /// </summary>
        /// <param name="action"></param>
        /// <param name="pathGenerator"></param>
        /// <remarks>Do not stores passed path or PathGenerator</remarks>
        public async void GenerateNextGrid(Action<GridGeneratorOutput> action, RoadGenerator pathGenerator)
        {
            var generatedPath = await pathGenerator.GeneratePathAsync();
            var generatedGrid = await GenerateGridAsync(generatedPath);
            action?.Invoke(generatedGrid);
        }

        private Task<GridGeneratorOutput> GenerateGridAsync(Deque<RoadDirection> generatedPath)
        {
            return TaskExtensions.CreateTask(() => GenerateGrid(generatedPath));
        }

        private GridGeneratorOutput GenerateGrid(Deque<RoadDirection> generatedPath)
        {
            var cellGrid = new ICellEntity[_columnsCount, _rowCount];
            var currentPosition = StartPosition(_lastEntity);
            RoadDirection entityType;

            if (_lastEntity == RoadDirection.None)
            {
                entityType = generatedPath.Last;
                generatedPath.RemoveLast();
            }
            else
            {
                entityType = _lastEntity;
            }
            var cell = _preset.GetCell(entityType.Negative(), entityType);
            var stepInOut = new LoopInOut(cell, currentPosition);
            cellGrid[currentPosition.Item1, currentPosition.Item2] = cell;
            var count = 0;
            var breakCount = generatedPath.Count + 1;

            while (count <= breakCount)
            {
                if (LoopStep(generatedPath, ref cellGrid, ref stepInOut)) break;
                count++;
            }

            for (var row = 0; row < _rowCount; row++)
            {
                for (var column = 0; column < _columnsCount; column++)
                {
                    cellGrid[column, row] ??= _preset.GetCell(RoadDirection.None, RoadDirection.None);
                }
            }
            _lastColumn = currentPosition.Item1;
            _lastRow = currentPosition.Item2;
            _lastEntity = stepInOut.PreviousCellEntity.OutDirection;
            return new GridGeneratorOutput(cellGrid, _lastEntity, count);
        }

        private TupleInt StartPosition(RoadDirection entityRoad)
        {
            var currentPosition = new TupleInt();

            switch (entityRoad)
            {
                case RoadDirection.South:
                    currentPosition.Item1 = _lastColumn;
                    currentPosition.Item2 = _rowCount - 1;
                    break;
                case RoadDirection.North:
                    currentPosition.Item1 = _lastColumn;
                    currentPosition.Item2 = 0;
                    break;
                case RoadDirection.West:
                    currentPosition.Item1 = _columnsCount - 1;
                    currentPosition.Item2 = _lastRow;
                    break;
                case RoadDirection.East:
                    currentPosition.Item1 = 0;
                    currentPosition.Item2 = _lastRow;
                    break;
                case RoadDirection.None:
                    currentPosition.Item1 = _columnsCount / 2;
                    currentPosition.Item2 = 0;
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
            return currentPosition;
        }

        private bool LoopStep(Deque<RoadDirection> generatedPath, ref ICellEntity[,] cellGrid, ref LoopInOut loopInOut)
        {
            var next = generatedPath.RemoveLast();
            var inDir = loopInOut.PreviousCellEntity.OutDirection.Negative();
            var nextCell = _preset.GetCell(inDir, next);
            var currentPosition = loopInOut.CurrentPosition;
            var prevPosition = new TupleInt(currentPosition);
            cellGrid[currentPosition.Item1, currentPosition.Item2] = nextCell;

            switch (next)
            {
                case RoadDirection.North:
                    currentPosition.Item2++;
                    break;
                case RoadDirection.East:
                    currentPosition.Item1++;
                    break;
                case RoadDirection.South:
                    currentPosition.Item2--;
                    break;
                case RoadDirection.West:
                    currentPosition.Item1--;
                    break;
                case RoadDirection.None:
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            var value = false;
            
            if ((currentPosition.Item1 >= _columnsCount || currentPosition.Item1 < 0) &&
                (next == RoadDirection.East || next == RoadDirection.West))
            {
                currentPosition.Item1 = prevPosition.Item1;
                cellGrid[prevPosition.Item1, currentPosition.Item2] = nextCell;
                value = true;
            }

            if ((currentPosition.Item2 >= _rowCount || currentPosition.Item2 < 0) &&
                (next == RoadDirection.North || next == RoadDirection.South))
            {
                currentPosition.Item2 = prevPosition.Item2;
                cellGrid[currentPosition.Item1, prevPosition.Item2] = nextCell;
                value = true;
            }

            loopInOut = new LoopInOut(nextCell, currentPosition);
            
            return value;
        }

        [Serializable]
        private readonly ref struct LoopInOut
        {
            public ICellEntity PreviousCellEntity { get; }
            public TupleInt CurrentPosition { get; }

            public LoopInOut(ICellEntity previousCellEntity, TupleInt currentPosition)
            {
                PreviousCellEntity = previousCellEntity;
                CurrentPosition = currentPosition;
            }
        }
    }
}
